---
title: 'Quickstart'
description: 'Follow this tutorial to start signing everything.'
---

<img
    className="block dark:hidden"
    src="/logo/healthKERI-logo-primary-black.png"
    alt="Hero Light"
/>
<img
    className="hidden dark:block"
    src="/logo/healthkeri-main-logo.png"
    alt="Hero Dark"
/>
## Overview

We've provided a Docker image and Docker compose files to get started configuring secure data exchange quickly.

<Tip>
    **Note**: Please see [Software](/software) to get the necessary software for this tutorial. <br />
</Tip>


1. [Launch healthKERI RACK and Mirth Connect](#1-launch-healthkeri-rack-and-mirth-connect).
2. [Create local identifiers with Locksmith](#2-create-local-identifiers-with-locksmith)
3. [Connect to RACK Gateways through Locksmith](#3-connect-to-rack-gateways-through-locksmith)
4. [Configure Outbound Route](#4-configure-outbound-route)
5. [Configure Inbound Route](#5-configure-inbound-route)
6. [Launch Routing](#6-launch-routing)
7. [Send Test Data](#7-send-test-data)
8. [Verify Results](#8-verify-results)
9. [Next Steps](#9-next-steps)

## 1. Launch healthKERI RACK and Mirth Connect

This tutorial will show you how to launch two <Tooltip tip="Routing, Authentication and Confidentiality with KERI">RACK</Tooltip> Gateways and configure them to sign and encrypt all data exchanged
between two Mirth Connect integration engine instances.

<AccordionGroup>
    <Accordion title="What is Mirth Connect">
        Mirth Connect is an open-source integration engine designed for data exchange in the healthcare industry. It enables
        communication between disparate information systems by supporting various healthcare data exchange standards, namely, HL7 and FHIR
        for text based patient health information, and DICOM for medical imaging transfer. Mirth Connect is intended to
        facilitate the routing, transformation, and filtering of clinical data between different healthcare sectors and their
        associated information systems. It is used to integrate data from hospitals, clinics, imaging centers,
        laboratories, and pharmacies, and more. For the purposes of this tutorial, Mirth Connect serves as a stand-in for any
        given integration engine used in the HealthCare sector.
    </Accordion>
</AccordionGroup>

In the `rack-docker` repository there is a Docker compose file called `mirth-connect-rack-compose-sample.yaml` that can be used to launch two instances of <Tooltip tip="Routing, Authentication and Confidentiality with KERI">RACK</Tooltip> and two instances of Mirth Connect using the following command:

```bash Docker Compose
docker compose -f ./examples/mirth-connect-rack-compose-sample.yaml up
```

In addition to the two instances of <Tooltip tip="Routing, Authentication and Confidentiality with KERI">RACK</Tooltip> and Mirth, this compose file also creates two temporary containers that create one [channel](https://docs.nextgen.com/bundle/Mirth_User_Guide_4_5_0/page/connect/connect/topics/c_Channel_Components_connect_ug.html) on each Mirth Connect instance that are preconfigured to work with the <Tooltip tip="Routing, Authentication and Confidentiality with KERI">RACK</Tooltip> instances after this tutorial is complete.
The channels are created and started.  You should see the following output on your terminal window which indicates that the all containers are operational and ready for the rest of the tutorial:

``` bash Dockere Compose
mirth-cli-2-1      | Importing channel: /opt/connect/channels/mirth2-to-file-from-rack2-http.xml
mirth-cli-1-1      | Importing channel: /opt/connect/channels/mirth1-file-to-rack1-http.xml
mirth-cli-1-1      | Connected to Mirth Connect server @ https://172.31.0.2:8443 (4.5.0)
mirth-cli-1-1      | Executing statement: import "/opt/connect/channels/mirth1-file-to-rack1-http.xml"
mirth-cli-2-1      | Connected to Mirth Connect server @ https://172.31.0.3:8443 (4.5.0)
mirth-cli-2-1      | Executing statement: import "/opt/connect/channels/mirth2-to-file-from-rack2-http.xml"
mirth-cli-2-1      | Channel 'HTTP to JSON File' imported successfully.
mirth-cli-2-1      | Executing statement: deploy
mirth-cli-2-1      | Deploying Channels
mirth-cli-1-1      | Channel 'JSON File to HTTP' imported successfully.
mirth-cli-1-1      | Executing statement: deploy
mirth-cli-1-1      | Deploying Channels
mirth-cli-2-1      | No Channels to Deploy
mirth-cli-2-1      | Executing statement: channel enable *
mirth-cli-2-1      | Executing statement: channel start *
mirth-cli-1-1      | No Channels to Deploy
mirth-cli-1-1      | Executing statement: channel enable *
mirth-cli-2-1      | Disconnected from server.
mirth-cli-1-1      | Executing statement: channel start *
mirth-cli-1-1      | Disconnected from server.
mirth-cli-2-1 exited with code 0
mirth-cli-1-1 exited with code 0

```

<Warning>The gateways launched in this tutorial were installing using the `--insecure` option.  They should **only** be used for local testing and experimentation.</Warning>

#### CESR Files and Out-Of-Band-Introductions
In order for <Tooltip tip="Routing, Authentication and Confidentiality with KERI">RACK</Tooltip> gateways to communicate with each other securely they need to be aware of each other's [key state](/essentials/overview) (the current set of signing keys to use for signature verification and encryption).
  We accomplish this connection by exchanging each gateway's key event log in [CESR](https://trustoverip.github.io/tswg-cesr-specification/) encoded stream files in an Out-Of-Band-Introduction (OOBI).  These files are exported during the `rack install` command that created the Docker images and must be exported from each docker container now running a <Tooltip tip="Routing, Authentication and Confidentiality with KERI">RACK</Tooltip> gateway.

To copy these <Tooltip tip="Composable Event Streaming Representation">CESR</Tooltip> files out of docker containers, use the following commands:

```bash Docker
docker cp examples-rack-1-1:/opt/rack/data/Rack1-core.cesr ./rack-1.cesr
docker cp examples-rack-2-1:/opt/rack/data/Rack2-core.cesr ./rack-2.cesr
```

We will be using these <Tooltip tip="Composable Event Streaming Representation">CESR</Tooltip> files later in the tutorial.

## 2. Create local identifiers with Locksmith
Our local <Tooltip tip="Key Event Receipt Infrastructure">KERI</Tooltip> wallet and secure <Tooltip tip="Encrypt Sender then Sign Receiver">ESSR</Tooltip> proxy is called [Locksmith](http://localhost:3000/software#download-and-install).
You will use `Locksmith` for the rest of this tutorial to establish secure connections to the <Tooltip tip="Routing, Authentication and Confidentiality with KERI">RACK</Tooltip> gateways Administration User Interface (AUI).

The first step is using Locksmith is to create and open a `Vault` that will hold the Identifiers used for the remainder of this tutorial.

<Steps>
    <Step title="Create Vault">
        After launching Locksmith for the first time you will be presented with a button labeled "Initialize new Vault".
        <img alt="Initialize New Vault" src="/images/initialize-new-vault.png"></img>
        Select this button and create a new vault named `Locksmith`:
        <img alt="Create Vault Dialog" src="/images/create-vault-dialog.png"></img>

    </Step>
    <Step title="Open Vault">
        After creating the Vault you open it using the drawer icon <Icon icon="inbox"></Icon> in the upper right corner of the Locksmith window and selecting the Locksmith drawer:
        <img alt="Open Vault" src="/images/open-vault.png"></img>
    </Step>
    <Step title="Create Identifier">
        Now, let's create your first Identifier. The <Tooltip tip="Routing, Authentication and Confidentiality with KERI">RACK</Tooltip> gateways were installing into the Docker images with predetermined cryptographic salts for both the <Tooltip tip="Administration User Interface">AUI</Tooltip> identifier as well as the identifier that is authorized to access the <Tooltip tip="Administration User Interface">AUI</Tooltip>.
        To connect to the <Tooltip tip="Routing, Authentication and Confidentiality with KERI">RACK</Tooltip> gateways, you must create a local identifier with the same salt that each gateway was initialized with.

        That salt is `DQ7Hzp4faFdbesNx-_a1v`.

        From the Identifiers screen, select the "Add Identifier" button to create your first identifier:
        <img alt="Identifiers" src="/images/identifiers.png"></img>

        Set the name for the new Identifier as "admin", click on "Advanced Configuration" and copy and paste the salt listed above into the Salt field.  Click on the eye ball next to the Salt field to see that you pasted the correct value.
        <img alt="Create Identifier" src="/images/add-identifier.png"></img>

        After you click "Add", the new identifier appear in the grid with the name "admin" and the AID of `EK4iFDRWMPH2mJ_VSJZt5VgCTg7wupzKX5nipreSOBuR`.

        <Note>It is important to use the name "admin" for this identifier since the name becomes part of the entropy used to create the first set of key pairs.</Note>

    </Step>
</Steps>

## 3. Connect to RACK Gateways through Locksmith
Your connection to the <Tooltip tip="Administration User Interface">AUI</Tooltip> for each <Tooltip tip="Routing, Authentication and Confidentiality with KERI">RACK</Tooltip> gateway is secured using the same <Tooltip tip="Key Event Receipt Infrastructure">KERI</Tooltip> and <Tooltip tip="Encrypt Sender then Sign Receiver">ESSR</Tooltip> technology at the heart of our gateways.
To establish a secure connection to each gateway you have to load the <Tooltip tip="Composable Event Streaming Representation">CESR</Tooltip> files copied from the running Docker containers in [Step 1.](#1-launch-healthkeri-rack-and-mirth-connect).
<Steps>
    <Step title="Create Remote Gateways">
        Select the <Icon icon="envelope"></Icon> "Remote Identifiers" icon from the left menu
        <img alt="Remote Identifiers" src="/images/remote-identifiers.png"></img>
        Click on "Add Remote Identifiers" and in the dialog, click the **File** radio button, add an **Alias** of "Rack1" and **Browse** for the "rack-1.cesr" file exported from the Docker container earlier:
        <img alt="Connect to Remote Identifier" src="/images/connect-remote-identifier.png"></img>

        Repeat these steps to connect to the second gateway with an **Alias** of "Rack2 and the "rack-2.cesr" **File**.

        When complete you should have 2 Remote Identifiers listed on the screen, Rack 1 with an AID of `EPIa-VqM9y2EUUMAJ0MAv5AEdDVvaOcFmIxKn5jzIgKk` and Rack2 with an AID of `EJ8Rx6lal6S7mlrhp6OuHkxAizP7N5ufzllu4YIbjjvV`.

    </Step>
    <Step title="Create Proxies">
        Proxies are the final step required to launch the <Tooltip tip="Administration User Interface">AUI</Tooltip> screens for each gateway.  Each proxy will sign and encrypt all communication from your web browser to the gateway and decrypt and verify all data retrieved from the remote gateway.

        <img alt="Proxies" src="/images/proxies.png"></img>
        Click on the **Add Proxy Redirect** button to create a proxy.  Select "admin" from the **Associated Local AID** dropdown to use the identifier created in [Step 2.](#2-create-local-identifiers-with-locksmith), and select Rack1 in the **Destination Remote AID** dropdown.
        The **Target URL** and **Target Port** should populate automatically.
        <img alt="Create Proxy" src="/images/create-proxy.png"></img>

        Repeat these steps to create a proxy to the second gateway by selecting "Rack2" in the **Destination Remote AID** dropdown.

        When complete you should not have 2 Proxies listed on the screen, one for Rack1 and one for Rack2, each using the same **Signing AID**.
    </Step>
    <Step title="Launch Proxies">
        To launch the <Tooltip tip="Administration User Interface">AUI</Tooltip> for Rack1, select the **Actions** menu for that row in the grid and click on the **Launch** menu.  The status will change from **<font color="red" weight="bold">Idle</font>** to **<font color="green" weight="bold">Running</font>**.
        <img alt="Launch Proxies" src="/images/launch-proxy.png"></img>
    </Step>
    <Step title="Access RACK Gateways">
        You should now have two open browser windows, one for Rack1 and one for Rack2 showing the <Tooltip tip="Administration User Interface">AUI</Tooltip> for each gateway.
        <img alt="RACK Gateways" src="/images/gateways.png"></img>
    </Step>
</Steps>

## 4. Configure Outbound Route
We will use the gateway named **Rack1** as our Outbound Route.  The first pre-configured instance of Mirth, **Mirth1** has a channel created to load any files placed in a certain directory and send them to the IP address of **Rack1** at port 3333.
In this step, we will create an Outbound Route on **Rack1** that listens on port 3333 and signs, encrypts and sends data to **Rack2**.

<Steps>
    <Step title="Create RACK Identifier">
        Select the "Identifiers" item from the left menu:
        <img alt="RACK Identifiers" src="/images/rack-identifiers.png"></img>
        Click on "Add Identifier" and in the dialog, give the identifier an **Alias** of "Rack1" and set the **Number of Signing Keys**, **Number of Rotation Keys**, **Signing Threshold** and **Rotation Threshold** all to `1`:
        <img alt="Create RACK Identifier" src="/images/rack-create-identifier.png"></img>
        Click **Save** to create an Identifier that is local to this <Tooltip tip="Routing, Authentication and Confidentiality with KERI">RACK</Tooltip> gateway.

    </Step>
    <Step title="Create Outbound Routes">
        Now we will define the Outbound Route to the **Rack2** gateway.  This is done from the **Outbound Routes** menu item on the left:

        <img alt="Outbound Routes" src="/images/outbound-routes.png"></img>
        Click on the **Add Outbound Route** button to create the route.

        Give the Outbound Route an **Name** of "To Rack2" (to indicate the data's destination), leave the **Peer-to-Peer** radio button selected, select the "Rack1" Identifier you just created from the **Local Identifier to Secure the Connection**, leave the **Protocol** set to "HTTP" and set the **Local Port* to 3333.

        <img alt="Create Outbound Route" src="/images/create-outbound-route.png"></img>
        Click **Save** to create the Outbound Route to **Rack2**.

    </Step>
    <Step title="Export Introduction">
        The two <Tooltip tip="Routing, Authentication and Confidentiality with KERI">RACK</Tooltip> gateways will be connected to each other using the same <Tooltip tip="Composable Event Streaming Representation">CESR</Tooltip> file approach we used to connect Locksmith to each gateway.
        To establish this connection you will not export an introduction to the Identifier you created for this <Tooltip tip="Routing, Authentication and Confidentiality with KERI">RACK</Tooltip> gateway from the Outbound Route grid.
        <Note>We export introductions from the route grids so they also contain gateway connection information that allows them to be discovered by other gateways </Note>
        <img alt="Export Introduction" src="/images/outbound-export-introduction.png"></img>
        Open the Actions menu for the Outbound Route you just created and select the Export Introduction menu item.  A new file will be saved on your computer named "Rack1-To Rack2.cesr".  We will use this file in the next step.
    </Step>
</Steps>

## 5. Configure Inbound Route
**Rack2** now becomes our inbound <Tooltip tip="Routing, Authentication and Confidentiality with KERI">RACK</Tooltip> gateway.  The second pre-configured instance of Mirth, **Mirth2** has a channel created is listening on port 5555 for inbound HTTP JSON files that it will write to a local directory.

In this step, we will create an Inbound Route on **Rack2** that listens on port 4444 for signed and encrypted data sent from **RACK2**.  No other data will be accepted into this instance of <Tooltip tip="Routing, Authentication and Confidentiality with KERI">RACK</Tooltip> and therefore the **Mirth2** instance of Mirth Connect.

<Steps>
    <Step title="Create RACK Identifier">
        From the "Identifiers" screen on **Rack2**, click on "Add Identifier" and in the dialog, give the identifier an **Alias** of "Rack2" and set the **Number of Signing Keys**, **Number of Rotation Keys**, **Signing Threshold** and **Rotation Threshold** all to `1`:
        <img alt="RACK Identifiers" src="/images/rack-create-inbound-identifier.png"></img>

        Click **Save** to create an Identifier that is local to this <Tooltip tip="Routing, Authentication and Confidentiality with KERI">RACK</Tooltip> gateway.

    </Step>
    <Step title="Connect to Remote Gateway">
        Because we exported an introduction from **Rack1** we are able to create a remote gateway on **Rack2** before creating the Inbound Route.

        Select "Remote Gateways" from the menu on the left side of the **Rack2** <Tooltip tip="Administration User Interface">AUI</Tooltip>:
        <img alt="Remote Gateways" src="/images/remote-gateways.png"></img>

        Click on **Add Remote Gateway**, set the **Alias** to "Rack1" and select the "Rack1-to Rack2.cesr" file exported from [Step 4.](#4-configure-outbound-route) above.
        <img alt="Create Remote Gateway" src="/images/create-remote-gateway.png"></img>

        Click on **Save** to load the key state and connection information from **Rack1** into the **Rack2** gateway.

        <Tip>**Remember**: Everything in <Tooltip tip="Key Event Receipt Infrastructure">KERI</Tooltip> is "End-to-End Verifiable".  Each gateway verifies all key events and their signatures before accepting the key state into their own database.</Tip>
    </Step>
    <Step title="Create Inbound Routes">
        Now we will define the Inbound Route from the **Rack1** gateway.  This is done from the **Inbound Routes** menu item on the left:

        <img alt="Inbound Routes" src="/images/inbound-routes.png"></img>
        Click on the **Add Inbound Route** button to create the route.

        Give the Inbound Route an **Name** of "From Rack1" (to indicate the data's origin).

        In the **Route Type** section, leave the **Peer-to-Peer** radio button selected, select the "Rack1" Identifier you just imported from the **Accept from Remote Gateway**, select the "172.31.0.5" IP address and enter 4444 in ** Accept on Port**.

        Leave the **Protocol** set to "HTTP" set destination **IP Address / Host Name** to "172.31.0.3" the **Port* to 5555.  That IP Address is the static IP address assigned to the **Mirth2** instance in the Docker compose file.  Also, the channel created in **Mirth2** is set to listen for incoming HTTP connections on port 5555.

        <img alt="Create Inbound Route" src="/images/create-inbound-route.png"></img>
        Click **Save** to create the Inbound Route from **Rack1**.

    </Step>
    <Step title="Export Introduction">
        As we did with the Outbound Route on **Rack1** we must export the introduction to **Rack2**, but this time from the Inbound Route grid:
        <img alt="Export Introduction" src="/images/inbound-export-introduction.png"></img>
        Open the Actions menu for the Inbound Route you just created and select the Export Introduction menu item.  A new file will be saved on your computer named "Rack2-From Rack1.cesr".  We will use this file in the [next step](#6-launch-routing).
    </Step>
</Steps>

## 6. Launch Routing
We will now complete the connection between the two gateways by loading the <Tooltip tip="Composable Event Streaming Representation">CESR</Tooltip> file from **Rack2** into **Rack1** and updating the Outbound Route we created in [Step 4.](#4-configure-outbound-route).

<Steps>
    <Step title="Complete Gateway Connections">
        Back on the **Rack1** in the **Remote Gateways** section, click on **Add Remote Gateway**, set an **Alias** of "Rack2" and select the "Rack2-From Rack1.cesr" file create in the last step:
        <img alt="RACK Identifiers" src="/images/rack2-create-remote.png"></img>

        Click on **Save** to load the key state and connection information from **Rack2** into the **Rack1** gateway.

    </Step>
    <Step title="Edit Outbound Route">
        Because we created the Outbound Route first we were not able to select the destination Remote Gateway.  Navigate to the **Outbound Routes** section of **Rack1*, select **Edit** from the **Actions** menu of the Outbound Route and update **Send to Remote Gateway** to now point to "Rack2"
        <img alt="Edit Outbound Route" src="/images/edit-outbound-route.png"></img>

        Click **Save** to complete the route configuration for both gateways.
    </Step>
    <Step title="Launch Routes">
        Since you are now on the Outbound Routes grid of **Rack1**, you can launch this route by selecting **Launch** from the **Actions** menu of the Outbound Route named "To Rack2":

        <img alt="Create Remote Gateway" src="/images/launch-outbound.png"></img>

        Perform the same operation on the inbound route in the **Inbound Routes** on **Rack2**
        <img alt="Create Remote Gateway" src="/images/launch-inbound.png"></img>

        Both gateways are now launched as indicated by their status changing from **<font color="red" weight="bold">Idle</font>** to **<font color="green" weight="bold">Running</font>**.

        <Note>After one minute, the **Last Ping** value in each route will be updated with a timestamp indicating the gateways are now connected and able to exchange secure data.</Note>

    </Step>
</Steps>

<Check>You have now completed the configuration of two <Tooltip tip="Routing, Authentication and Confidentiality with KERI">RACK</Tooltip> gateways and can exchange secure data!</Check>

## 7. Send Test Data
As mentioned previously, the Docker compose file launched in [Step 1.](#1-launch-healthkeri-rack-and-mirth-connect) created 2 instances of Mirth Connect
and configured them with Channels that would send data through our newly configured <Tooltip tip="Routing, Authentication and Confidentiality with KERI">RACK</Tooltip> gateways.

**Mirth1** has a channel that is looking for any JSON files to be copied into its local `/opt/connect/data` directory that was mapped to the local `<rack-docker dir>/examples/data/volumes/mirth1` directory by Docker compose.
When files show up in that directory, **Mirth1** will send those files via HTTP to the IP address and Port that **Rack1** is now listening on.

To facilitate testing, we have provided 2 directories (`<rack-docker dir>/examples/data/fhir-dataset` and `<rack-docker dir>/examples/data/fhir-dataset-large`) of sample FHIR data files that can be used to test the new secure connection.  We also included a Shell script that will copy the files into the correct local directory to be picked up buy **Mirth1**.

To send test files through the secure connection use the following command from the `<rack-docker dir>/examples` directory:

```bash Load Test
./load-test.sh fhir-dataset 50
```

This command will copy 50 random files from the `examples/data/fhir-dataset` directory to the `examples/data/volumes/mirth1` directory which will cause **Mirth1** to pick up those files and send them to **Rack1**

**Rack1** will, in turn, sign and encrypt every file (the actual entire HTTP transaction, as a matter of fact) and send the now secured data to **Rack2** which will decrypt the data and recreate the HTTP transaction to send to **Mirth2**

Logging was left at the **INFO** level so you will see a series of log statements from **Rack1** and **Rack2** indicating the successful flow of data, such as the following:

```bash Rack
rack-1-1  | 2025-02-17 18:33:12 [rack] INFO   Behavior for /fwd missing or does not have verify for said=ENAjc5b0gQTJo_9LEk74ltUhiDVSsiqROsPXNZpZDses
rack-1-1  | 2025-02-17 18:33:12 [rack] INFO   Message from EAVyvgXvjcYxBZYDtbxpEaX4F6RLuyhrw_aagZaq0iXt to EPTKEkkVw9XuCsMQ4rdqIyK8bQJQyGHWlAaWg09LuGo7
rack-1-1  | 2025-02-17 18:33:12 [rack] INFO   tcp client cue received for evt=ENAjc5b0gQTJo_9LEk74ltUhiDVSsiqROsPXNZpZDses
rack-1-1  | 2025-02-17 18:33:12 [rack] INFO   tcp -> [EGVh6SBUMqWEsy5FSm2H4anB8OI4HdF70rtQxru_m6Hx]/[EMfZQm1_0YS6chhM6rV1jhC7Dwh5wBdQc0TpnpYaW6Er] -> dessr: msg recv.
rack-1-1  | 2025-02-17 18:33:12 [rack] INFO   tcp -> [EGVh6SBUMqWEsy5FSm2H4anB8OI4HdF70rtQxru_m6Hx]/[EMfZQm1_0YS6chhM6rV1jhC7Dwh5wBdQc0TpnpYaW6Er] -> dessr: msg sent.
rack-1-1  | 2025-02-17 18:33:12 [rack] INFO   Behavior for /essr/req missing or does not have verify for said=ED7e1Xs8MijyMnh_sF2TefIRQYwePUOFRKF4W4enacCm
rack-1-1  | 2025-02-17 18:33:12 [rack] INFO   dessr -> [EGVh6SBUMqWEsy5FSm2H4anB8OI4HdF70rtQxru_m6Hx]/[EMfZQm1_0YS6chhM6rV1jhC7Dwh5wBdQc0TpnpYaW6Er] -> httpsrv: msg recv.
rack-1-1  | 2025-02-17 18:33:12 [rack] INFO   dessr -> [EGVh6SBUMqWEsy5FSm2H4anB8OI4HdF70rtQxru_m6Hx]/[EMfZQm1_0YS6chhM6rV1jhC7Dwh5wBdQc0TpnpYaW6Er] -> httpsrv: msg sent.
rack-1-1  | 2025-02-17 18:33:12 [rack] INFO   Behavior for /http/rep missing or does not have verify for said=EHfg2cuhkXV0F3G8MoHi0CjBvyHXCjlZ_wHEsRBc-XFc
rack-1-1  | 2025-02-17 18:33:12 [rack] INFO   httpsrv sending 0 bytes for EAG3nLVV1uTw6zErIY2tYrw3qtMw1kj7g4N78C655dkd
rack-2-1  | 2025-02-17 18:33:12 [rack] INFO   Behavior for /fwd missing or does not have verify for said=ECsNTwvaF5GccfgyF3jOkJK52mBHX2xGj8M0S97hlUMO
rack-2-1  | 2025-02-17 18:33:12 [rack] INFO   Message from EK4iFDRWMPH2mJ_VSJZt5VgCTg7wupzKX5nipreSOBuR to EJ8Rx6lal6S7mlrhp6OuHkxAizP7N5ufzllu4YIbjjvV
rack-2-1  | 2025-02-17 18:33:12 [rack] INFO   exn with said=ECsNTwvaF5GccfgyF3jOkJK52mBHX2xGj8M0S97hlUMO saved
rack-2-1  | 2025-02-17 18:33:12 [rack] INFO   Server core: sent response protocol messages: 487
rack-2-1  | 2025-02-17 18:33:12 [rack] INFO   tcpsrv -> [EK4iFDRWMPH2mJ_VSJZt5VgCTg7wupzKX5nipreSOBuR]/[EJ8Rx6lal6S7mlrhp6OuHkxAizP7N5ufzllu4YIbjjvV] -> dessr: msg recv.
rack-2-1  | 2025-02-17 18:33:12 [rack] INFO   tcpsrv -> [EK4iFDRWMPH2mJ_VSJZt5VgCTg7wupzKX5nipreSOBuR]/[EJ8Rx6lal6S7mlrhp6OuHkxAizP7N5ufzllu4YIbjjvV] -> dessr: msg sent.
rack-2-1  | 2025-02-17 18:33:12 [rack] INFO   Behavior for /essr/req missing or does not have verify for said=EPCBtqy5MsjRMV7-55Qv3MNxOgyhrMrH25C9yWRHIAaf
rack-2-1  | 2025-02-17 18:33:12 [rack] INFO   dessr -> [EK4iFDRWMPH2mJ_VSJZt5VgCTg7wupzKX5nipreSOBuR]/[EJ8Rx6lal6S7mlrhp6OuHkxAizP7N5ufzllu4YIbjjvV] -> httpcall: msg recv.
rack-2-1  | 2025-02-17 18:33:12 [rack] INFO   dessr -> [EK4iFDRWMPH2mJ_VSJZt5VgCTg7wupzKX5nipreSOBuR]/[EJ8Rx6lal6S7mlrhp6OuHkxAizP7N5ufzllu4YIbjjvV] -> httpcall: msg sent.
rack-2-1  | 2025-02-17 18:33:12 [rack] INFO   Behavior for /ping missing or does not have verify for said=EEKa6p_xmPN8Hzeerls_NoDufr5cdNH2NkyAnlw44twL
rack-2-1  | 2025-02-17 18:33:12 [rack] INFO   Behavior for /ping missing or does not have handle for said=EEKa6p_xmPN8Hzeerls_NoDufr5cdNH2NkyAnlw44twL
```
<Icon icon="hand-horns" syle="emoji"></Icon> You have sent fully secure data in **Zero-Trust** between two Mirth Connect integrations instances without SSL!
## 8. Verify Results

The **Mirth2** instance is configured to write the files it receives from **Rack1** to its `/opt/connect/data` directory which was mapped to `examples/data/volumes/mirth2` by Docker compose.  To verify that the data flowed successfully through all 4 containers, you can check for new files that will now be in `examples/data/volumes/mirth2`:
```bash examples/data/volumes/mirth2
ls -a ./examples/data/volumes/mirth2
data/volumes/mirth2/1739817190096.dat-1739817190096-signed.json data/volumes/mirth2/1739817191043.dat-1739817191043-signed.json data/volumes/mirth2/1739817191876.dat-1739817191876-signed.json
data/volumes/mirth2/1739817190166.dat-1739817190166-signed.json data/volumes/mirth2/1739817191091.dat-1739817191091-signed.json data/volumes/mirth2/1739817191925.dat-1739817191925-signed.json
data/volumes/mirth2/1739817190226.dat-1739817190226-signed.json data/volumes/mirth2/1739817191136.dat-1739817191136-signed.json data/volumes/mirth2/1739817191968.dat-1739817191968-signed.json
data/volumes/mirth2/1739817190266.dat-1739817190266-signed.json data/volumes/mirth2/1739817191175.dat-1739817191175-signed.json data/volumes/mirth2/1739817192010.dat-1739817192010-signed.json
data/volumes/mirth2/1739817190315.dat-1739817190315-signed.json data/volumes/mirth2/1739817191225.dat-1739817191225-signed.json data/volumes/mirth2/1739817192057.dat-1739817192057-signed.json
data/volumes/mirth2/1739817190370.dat-1739817190370-signed.json data/volumes/mirth2/1739817191281.dat-1739817191281-signed.json data/volumes/mirth2/1739817192103.dat-1739817192103-signed.json
data/volumes/mirth2/1739817190416.dat-1739817190416-signed.json data/volumes/mirth2/1739817191338.dat-1739817191338-signed.json data/volumes/mirth2/1739817192151.dat-1739817192151-signed.json
data/volumes/mirth2/1739817190469.dat-1739817190469-signed.json data/volumes/mirth2/1739817191388.dat-1739817191388-signed.json data/volumes/mirth2/1739817192194.dat-1739817192194-signed.json
data/volumes/mirth2/1739817190528.dat-1739817190528-signed.json data/volumes/mirth2/1739817191440.dat-1739817191440-signed.json data/volumes/mirth2/1739817192236.dat-1739817192236-signed.json
data/volumes/mirth2/1739817190584.dat-1739817190584-signed.json data/volumes/mirth2/1739817191488.dat-1739817191488-signed.json data/volumes/mirth2/1739817192276.dat-1739817192276-signed.json
data/volumes/mirth2/1739817190640.dat-1739817190640-signed.json data/volumes/mirth2/1739817191535.dat-1739817191535-signed.json data/volumes/mirth2/1739817192318.dat-1739817192318-signed.json
data/volumes/mirth2/1739817190697.dat-1739817190697-signed.json data/volumes/mirth2/1739817191588.dat-1739817191588-signed.json data/volumes/mirth2/1739817192367.dat-1739817192367-signed.json
data/volumes/mirth2/1739817190755.dat-1739817190755-signed.json data/volumes/mirth2/1739817191636.dat-1739817191636-signed.json data/volumes/mirth2/1739817192416.dat-1739817192416-signed.json
data/volumes/mirth2/1739817190826.dat-1739817190826-signed.json data/volumes/mirth2/1739817191682.dat-1739817191682-signed.json data/volumes/mirth2/1739817192471.dat-1739817192471-signed.json
data/volumes/mirth2/1739817190880.dat-1739817190880-signed.json data/volumes/mirth2/1739817191726.dat-1739817191726-signed.json data/volumes/mirth2/1739817192523.dat-1739817192523-signed.json
data/volumes/mirth2/1739817190935.dat-1739817190935-signed.json data/volumes/mirth2/1739817191769.dat-1739817191769-signed.json data/volumes/mirth2/1739817192562.dat-1739817192562-signed.json
data/volumes/mirth2/1739817190990.dat-1739817190990-signed.json data/volumes/mirth2/1739817191820.dat-1739817191820-signed.json```
```

You can also diff those files to see that the full FHIR records have been transferred completely.

If you would like to verify that the data was sent between the <Tooltip tip="Routing, Authentication and Confidentiality with KERI">RACK</Tooltip> gateways signed and encrypted we recommend add a [Wireshark](https://hub.docker.com/r/linuxserver/wireshark) container to the `mirth-connect-rack-compose-sample.yaml` Docker compose file and analyze the network traffic between the `172.31.0.4` and `172.31.0.5` IP addresses.


## 9. Next Steps
Now that you've connected two <Tooltip tip="Routing, Authentication and Confidentiality with KERI">RACK</Tooltip> gateways directly via a Peer-To-Peer connection you should see one main limitation with this configuration.

At least one gateway will have to listen for incoming connections on a TCP port.  While this may be fine for local testing it can be challenging to test gateways on the Open Internet.

In our next tutorial, we will be demonstrating how to connect two <Tooltip tip="Routing, Authentication and Confidentiality with KERI">RACK</Tooltip> gateways using [healthKERI](https://healthKERI.com) Cloud Routers to remove this limitation.

Please stay tuned...
